---
sort: 2
---
# 驱动开发

前面 3 篇，学习 Ubuntu 操作系统、学习 ARM 裸机、学习系统移植，为驱动开发做准备。

裸机驱动开发的特点：底层，和寄存器接触，有些 MCU 提供了库，但是仍然比较底层(相比 linux)。

linux 下直接操作寄存器不现实，跑 linux 的芯片性能都还不错，外设相当复杂，如果直接去看手册，那还是挺复杂的。imx6ull 是应用处理器里比较低端的芯片。

因此 linux 下的驱动开发的思维是框架，根据各种 Linux 下的**驱动框架**进行开发。
- linux 驱动开发 ≈ 各种驱动框架的掌握。
- 驱动最终表现为 /dev/xxx 文件。应用文件 open/close/write/read
- 新内核支持设备树，.dts 文件描述了板上的设备信息。因此第一件事要去在设备树上添加设备


Linux 中的三大类驱动：
- 字符设备驱动
  - 最多，最繁杂
  - 如 IIC，
- 块设备驱动
  - 按照固定大小读写
  - EMMC，SD card，SSD
- 网络设备驱动
  - 有线网卡，无线网卡


USB 无线网卡 是什么类型的设备呢？两个属性都有。


驱动获取外设数据，控制外设，把数据给应用程序。linux 驱动开发不经要开发一个驱动，还要写一个简单的测试程序。MCU 开发中整个驱动和应用混杂在一起。

linux 下驱动和应用完全分开，操作系统内核和驱动运行在内核空间，应用程序运行在用户空间。应用程序想访问内核资源，三种方法：系统调用、异常(中断)和陷入(软中断)。

应用程序使用系统调用进入内核。



嵌入式Linux系统设计的一个关键概念就是用户应用与底层硬件的隔离。用户态应用程序不允许直接访问外设寄存器、存储媒介甚至内存。取而代之的是通过内核驱动来访问硬件，通过内存管理单元（MMU）来管理内存，应用程序则运行在虚拟地址空间。

这样的隔离提供了健壮性。假设Linux内核的运行是正确的，那么只允许内核操作底层硬件可以防止应用程序恶意或者无意地对硬件设备进行错误的配置，并进一步导致硬件设备处于未知状态。

这样的隔离也提供了可移植性。如果只有内核驱动管理硬件相关代码，将系统从一个硬件平台移植到另一个平台时只需要修改这些驱动就可以了。在不同的硬件平台中，应用程序调用的驱动API是一致的，这就允许应用程序在从一个平台迁移到另一个的时候，几乎可以不必对源代码做修改。

设备驱动可以表现为内核模块，也可以静态构建到内核镜像中。内核默认会将大部分驱动静态构建进去，因此它们会被自动加载。一个内核模块并不一定是设备驱动，这些内核模块仅仅是对内核的一个扩展。内核模块被加载到内核的虚拟地址空间。将设备驱动构建成模块使得开发更加容易，因为加载、测试以及卸载模块都可以在不重启内核的情况下进行。内核模块一般存放在根文件系统的 `/lib/modules/<kernel_version>/` 目录。




