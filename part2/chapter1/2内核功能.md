---
sort: 1
---
# 研究内核前


## RT-Thread 启动流程

从系统通电到进入 `main()` ，来看看这期间发生了什么事情。

我们从代码推测电路系统的运行，代码离最终的机器码序列还有段距离。RT-Thread 支持不同的编译器和不同芯片，因此代码略微有差异，但是都是先从 `.s` 汇编启动文件开始运行，然后执行 RT-Thread 的启动函数 `rtthead_startup()` ，最后进入用户入口函数 `main()` ，来自官方文档的一张图：

<figure>
    <img src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/basic/figures/rtt_startup.png" width=1200 />
</figure>

可以看出这期间还是做了不少事情的，芯片上电后，先运行汇编代码 `startup_stm32f103xe.s` ，然后跳转到 C 代码，进行 RT-Thread 系统功能初始化，最后才执行 `main()` 。

在使用 ARM CC 编译器时，用到了 `$Sub$$` 和 `$Super$$` 语法， `$Sub$$` 的含义是在程序执行前前插入一段新程序， 有点打补丁的意思。这个 `$Sub$$main` 可以先调用一些要补充在 `main` 之前的功能函数然后调用 `$Super$$main` 正式运行 `main()` 。正好这就是系统启动的功能，很合理，很符合使用裸机的思路，只关注 `main()` 即可。

主函数在文件 `components.c` 里“打了个补丁”，
```c
int $Sub$$main(void)
{
    rt_hw_interrupt_disable();
    rtthread_startup();
    return 0;
}
```
`$Sub$$main` 里调用了 `rtthread_startup();` 的，它也定义在这个源文件里：

```c
int rtthread_startup(void)
{
    rt_hw_interrupt_disable();

    /* 板级初始化：需在该函数内部进行系统堆的初始化 */
    rt_hw_board_init();

    /* 打印 RT-Thread 版本信息 */
    rt_show_version();

    /* 定时器初始化 */
    rt_system_timer_init();

    /* 调度器初始化 */
    rt_system_scheduler_init();

#ifdef RT_USING_SIGNALS
    /* 信号初始化 */
    rt_system_signal_init();
#endif

    /* 由此创建一个用户 main 线程 */
    rt_application_init();

    /* 定时器线程初始化 */
    rt_system_timer_thread_init();

    /* 空闲线程初始化 */
    rt_thread_idle_init();

    /* 启动调度器 */
    rt_system_scheduler_start();

    /* 不会执行至此 */
    return 0;
}

```

这个函数启动了与系统相关的硬件、内核对象、系统设备、各应用线程。更细致的分为四个部分：
- 初始化与系统相关的硬件；
- 初始化系统内核对象，例如定时器、调度器、信号；
- 创建 main 线程，在 main 线程中对各类模块依次进行初始化；
- 初始化定时器线程、空闲线程，并启动调度器。

`rt_hw_board_init();` 函数里完成了系统时钟设置、串口初始化、并把终端绑定到串口。

只有在启动调度器后，创建好的线程才会根据规则运行起来。


