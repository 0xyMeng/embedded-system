---
sort: 1
---
# RT-Thread 内核

```note
基本上是摘抄RTT官方文档。


```

这一部分内容去研究内核的功能。

<figure>
    <img src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/basic/figures/03kernel_Framework.png" width=600 />
    <figcaption>RT-Thread 内核架构图（官方文档）</figcaption>
</figure>

内核是包裹在硬件上的一层软件， RT-Thread 的内核包括内核库、实施内核。

C 库（ C 运行库，C Runtime Library）提供类似 `strcpy`等函数，有的也包括 `printf` 函数，RTT 的内核库大概也是干这个事情的，为了保证内核能实现 C 库里的这些功能，为了避免重名，这些函数加上了 `rt_` 前缀。

内核是多线程及其依赖功能的源码实现，比如线程管理与调度、线程之间通信、时钟管理、内存管理等。

```note
操作系统要考虑到不同的芯片，不同的编译器，因此，因为为了兼容性，需要去自己实现一套以避免编译器上的差异导致功能不可用。
```

下面更细致的看看内核的功能，并建立起操作系统的初步概念。


## 线程调度

操作系统的优势是多任务并发执行。在 RT-Thread 里，一个任务可以认为是一个“线程”。多线程并行执行首先要处理的问题是调度问题，在初学时知道内核帮我们做了这件事就可以了，不需要去研究底层算法。

```note
但是还是要说。线程调度算法是基于优先级的全抢占式多线程调度算法，即在系统中除了中断处理函数、调度器上锁部分的代码和禁止中断的代码是不可抢占的之外，系统的其他部分都是可以抢占的，包括线程调度器自身。支持 256 个线程优先级（也可通过配置文件更改为最大支持 32 个或 8 个线程优先级，针对 STM32 默认配置是 32 个线程优先级），0 优先级代表最高优先级，最低优先级留给空闲线程使用；同时它也支持创建多个具有相同优先级的线程，相同优先级的线程间采用时间片的轮转调度算法进行调度，使每个线程运行相应时间；另外调度器在寻找那些处于就绪状态的具有最高优先级的线程时，所经历的时间是恒定的，系统也不限制线程数量的多少，线程数目只和硬件平台的具体内存相关。

来自官方文档
```

## 线程同步与通信

线程同步这个问题是基于线程合作提出来的，一个线程依赖与另一个线程，此时就有了线程同步、死锁的问题。

线程合作还需要互相交流，传递信息（区别信号量这总信息），这就是线程之间的通信问题。

RT-Thread 采用信号量、互斥量与事件集实现线程间同步。线程通过对信号量、互斥量的获取与释放进行同步；互斥量采用优先级继承的方式解决了实时系统常见的优先级翻转问题。线程同步机制支持线程按优先级等待或按先进先出方式获取信号量或互斥量。线程通过对事件的发送与接收进行同步；事件集支持多事件的 “或触发” 和“与触发”，适合于线程等待多个事件的情况。

RT-Thread 支持邮箱和消息队列等通信机制。邮箱中一封邮件的长度固定为 4 字节大小；消息队列能够接收不固定长度的消息，并把消息缓存在自己的内存空间中。邮箱效率较消息队列更为高效。邮箱和消息队列的发送动作可安全用于中断服务例程中。通信机制支持线程按优先级等待或按先进先出方式获取。


## 内存管理

在裸机开发时，可能知道有内存这个事情的存在，但并不会过多关注。在操作系统里，内存需要被规划管理起来。这部分初学也是知道 RTOS 在帮我们做这件事就可以了。

RT-Thread 支持静态内存池管理及动态内存堆管理。当静态内存池具有可用内存时，系统对内存块分配的时间将是恒定的；当静态内存池为空时，系统将申请内存块的线程挂起或阻塞掉 (即线程等待一段时间后仍未获得内存块就放弃申请并返回，或者立刻返回。等待的时间取决于申请内存块时设置的等待时间参数)，当其他线程释放内存块到内存池时，如果有挂起的待分配内存块的线程存在的话，则系统会将这个线程唤醒。

动态内存堆管理模块在系统资源不同的情况下，分别提供了面向小内存系统的内存管理算法及面向大内存系统的 SLAB 内存管理算法。

还有一种动态内存堆管理叫做 memheap，适用于系统含有多个地址且不连续的内存堆。使用 memheap 可以将多个内存堆 “粘贴” 在一起，让用户操作起来像是在操作一个内存堆。

## IO设备管理

这是一种思想，可能刚开始用的时候感觉还不如裸机直接搞方便，但是操作系统是站在了更高的层次去做这件事情。

RT-Thread 将 PIN、I2C、SPI、USB、UART 等作为外设设备，统一通过设备注册完成。实现了按名称访问的设备管理子系统，可按照统一的 API 界面访问硬件设备。在设备驱动接口上，根据嵌入式系统的特点，对不同的设备可以挂接相应的事件。当设备事件触发时，由驱动程序通知给上层的应用程序。







