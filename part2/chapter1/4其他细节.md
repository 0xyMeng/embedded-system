---
sort: 4
---
# 其他细节

## 程序内存分布

MCU 有的存储空间：片内 Flash 和片内 RAM ，编译完成的程序会包含几种类型的数据存放在 MCU 不同的存储区。在 Keil 里编译完成后在 Build Output 串口会哟编译输出信息：
```
linking...
Program Size: Code=48008 RO-data=5660 RW-data=604 ZI-data=2124
After Build - User command \#1: fromelf --bin.\\build\\rtthread-stm32.axf--output rtthread.bin
".\\build\\rtthread-stm32.axf" - 0 Error(s), 0 Warning(s).
Build Time Elapsed: 00:00:07
```

上面提到的 Program Size 包含以下几个部分：
- Code：代码段，存放程序的代码部分；
- RO-data：只读数据段，存放程序中定义的常量；
- RW-data：读写数据段，存放初始化为非 0 值的全局变量；
- ZI-data：0 数据段，存放未初始化的全局变量及初始化为 0 的变量；

编译完工程会生成一个 .map 的文件，该文件说明了各个函数占用的尺寸和地址，在文件的最后几行也说明了上面几个字段的关系：

```
==============================================================================

    Total RO  Size (Code + RO Data)                 9352 (   9.13kB)
    Total RW  Size (RW Data + ZI Data)              2048 (   2.00kB)
    Total ROM Size (Code + RO Data + RW Data)       9404 (   9.18kB)

==============================================================================
```

RO 表示程序占用 Flash 的大小， RW 表示了程序运行时占用 RAM 的大小， ROM 表示烧写程序占用的 Flash 大小。

烧录到 STM32 为 bin 或者 hex 文件，称为**可执行映像文件**，映像文件在 Flash 里的内存分布和 MCU 上电后在 RAM 里的内存分布略有区别：

<figure>
    <img src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/basic/figures/03Memory_distribution.png" width=550 />
</figure>

可执行映像文件包含了 RO 和 RW 两部分，未初始化或者初始化为 0 的变量不占用映像存储空间。

STM32 默认上电后从 Flash 启动，启动后有个把 RW 段数据搬到 RAM 的过程，RO 段的数据不会动，也就是说 CPU 可以直接在 Flash 上读代码。此外对于 ZI 数据，根据编译器给出的地址和大小分配 ZI 段，并清零。


```
Flash 只读不写， RAM 断电丢失数据。可以直接原地执行代码的设备称为XiP设备，比如 NOR Flash，直接挂在数据总线上。

此外还有 SPI Flash ，SPI 接口显然和总线接口不一样，因此需要把里面的内容搬到一个可以被数据总线读取的地方，大概是这么个思路。
```

剩下的没使用的 RAM 内存空间就是**动态内存堆**，在向操作系统请求内存时，分配的都是这一部分的。比如说一个小李子：
```c
rt_uint8_t *msg_ptr;
msg_ptr = (rt_uint8_t*)rt_malloc(128);
rt_memset(msg_ptr, 0, 128);
```
指针 `msg_ptr` 指向了一个 128 Byte 的内存堆，并把值全部设置为0。

RW 段存放有初值的全局变量，ZI 段存放初值为0的全局变量。

## RT-Thread 自动初始化机制

自动初始化指的是初始化函数不需要被显式调用，只需要通过一个宏定义方式进行声明，就会在系统启动过程中被执行。

举个例子：
```c
int rt_hw_usart_init(void)  /* 串口初始化函数 */
{
     ... ...
     /* 注册串口 1 设备 */
     rt_hw_serial_register(&serial1, "uart1",
                        RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
                        uart);
     return 0;
}
INIT_BOARD_EXPORT(rt_hw_usart_init);    /* 使用组件自动初始化机制 */
```

`INIT_BOARD_EXPORT(rt_hw_usart_init)` 就可以实现在系统启动时自动运行这个函数。

这种声明的函数是被 `rt_components_board_init()` 与 `rt_components_init()`，调用的。


rt_components_board_init() 函数执行的比较早，主要初始化相关硬件环境，执行这个函数时将会遍历通过 INIT_BOARD_EXPORT(fn) 申明的初始化函数表，并调用各个函数。

rt_components_init() 函数会在操作系统运行起来之后创建的 main 线程里被调用执行，这个时候硬件环境和操作系统已经初始化完成，可以执行应用相关代码。rt_components_init() 函数会遍历通过剩下的其他几个宏申明的初始化函数表。



## 内核对象模型

内核对象实际就是内核里面这些东西，这些东西是如何实现出来的，实现的时候用了面向对象的思想。

<figure>
    <img src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/basic/figures/03kernel_object2.png
" width=600 />
</figure>

这个图表示了内核里这些东西的关系，他们都需要名字，因此有个基类，在基类上扩展自己的属性。

上图中由对象控制块 rt_object 派生出来的有：线程对象、内存池对象、定时器对象、设备对象和 IPC 对象（IPC：Inter-Process Communication，进程间通信。在 RT-Thread 实时操作系统中，IPC 对象的作用是进行线程间同步与通信）；由 IPC 对象派生出信号量、互斥量、事件、邮箱与消息队列、信号等对象。

对象控制块 rt_object 的数据结构：
```c
struct rt_object
{
    /* 内核对象名称     */
    char      name[RT_NAME_MAX];
    /* 内核对象类型     */
    rt_uint8_t  type;
    /* 内核对象的参数   */
    rt_uint8_t  flag;
    /* 内核对象管理链表 */
    rt_list_t   list;
};

```

内核对象容器的数据结构
```c
struct rt_object_information
{
    /* 对象类型 */
    enum rt_object_class_type type;
    /* 对象链表 */
    rt_list_t object_list;
    /* 对象大小 */
    rt_size_t object_size;
};
```

一类对象由一个 rt_object_information 结构体来管理，每一个这类对象的具体实例都通过链表的形式挂接在 object_list 上。而这一类对象的内存块尺寸由 object_size 标识出来（每一类对象的具体实例，他们占有的内存块大小都是相同的）。



