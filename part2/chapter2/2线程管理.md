---
sort: 2
---
# 线程管理

## 线程管理接口

最基本的线程管理接口：
```c
/* 线程创建 */
rt_thread_t rt_thread_create(const char* name,
                            void (*entry)(void* parameter),
                            void* parameter,
                            rt_uint32_t stack_size,
                            rt_uint8_t priority,
                            rt_uint32_t tick);

/* 线程启动 */
rt_err_t rt_thread_startup(rt_thread_t thread);

/* 线程删除 */
rt_err_t rt_thread_delete(rt_thread_t thread);
```
此外还有一些接口，用到了再说
```c
/* 线程控制 */
rt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void* arg);

```


## 线程使用示例

举个例子，使用大疆的 Robomaster 开发板 a 板，主控芯片是 STM32F427 ，使用板上的 10 个 LED 简单的玩玩多线程，设计三个小功能
- 1.用8个LED做流水灯
- 2.一个LED每200ms亮100ms，快速闪烁
- 3.一个LED每900ms亮100ms，慢闪烁

在官方SDK基础上新建一个led.c文件

```c
#include <rtthread.h>
#include <rtdevice.h>
#include <board.h>

#define LED_FLOW_PRIORITY         27
#define LED_FLOW_STACK_SIZE       256
#define LED_FLOW_TIMESLICE        5

#define LED_FAST_PRIORITY         25
#define LED_FAST_STACK_SIZE       256
#define LED_FAST_TIMESLICE        5

#define LED_SLOW_PRIORITY         26
#define LED_SLOW_STACK_SIZE       256
#define LED_SLOW_TIMESLICE        5


#define LED1_PIN    GET_PIN(G, 1)
/* PG1 - PG8 */
#define LED8_PIN    GET_PIN(G, 8)
#define LED9_PIN    GET_PIN(E, 11)
#define LED10_PIN   GET_PIN(F, 14)

/*-------------------------------   线程1：流水灯   -------------------------------*/
static rt_thread_t led_flow = RT_NULL;

static void led_flow_thread(void *parameter)
{
  rt_pin_mode(LED1_PIN, PIN_MODE_OUTPUT);
  /* PG1 - PG8 */
  rt_pin_mode(LED8_PIN, PIN_MODE_OUTPUT);
  rt_pin_write(LED1_PIN, PIN_HIGH);
  /* PG1 - PG8 */
  rt_pin_write(LED8_PIN, PIN_HIGH);

  while (1)
  { /* 依次点亮LED */
    rt_pin_write(LED1_PIN, PIN_LOW);
    rt_thread_mdelay(100);
    rt_pin_write(LED2_PIN, PIN_LOW);
    rt_thread_mdelay(100);
    rt_pin_write(LED3_PIN, PIN_LOW);
    rt_thread_mdelay(100);
    rt_pin_write(LED4_PIN, PIN_LOW);
    rt_thread_mdelay(100);
    rt_pin_write(LED5_PIN, PIN_LOW);
    rt_thread_mdelay(100);
    rt_pin_write(LED6_PIN, PIN_LOW);
    rt_thread_mdelay(100);
    rt_pin_write(LED7_PIN, PIN_LOW);
    rt_thread_mdelay(100);
    rt_pin_write(LED8_PIN, PIN_LOW);
    
    rt_thread_mdelay(1000); /* 1s后全部熄灭 */
    rt_pin_write(LED1_PIN, PIN_HIGH);
    /* PG1 - PG8 */
    rt_pin_write(LED8_PIN, PIN_HIGH);
    
    rt_thread_mdelay(1000);
  }
}

int led_flow_start(void)
{
  led_flow = rt_thread_create("led_flow",
                              led_flow_thread, 
                              RT_NULL,
                              LED_FLOW_STACK_SIZE,
                              LED_FLOW_PRIORITY, 
                              LED_FLOW_TIMESLICE); 

  if (led_flow != RT_NULL)
      rt_thread_startup(led_flow);
  
  return 0;
}

MSH_CMD_EXPORT(led_flow_start, led flow start);


/*-------------------------------   线程2：快闪   -------------------------------*/
static rt_thread_t led_fast_flash = RT_NULL;

static void led_fast_flash_thread(void *parameter)
{
    rt_pin_mode(LED9_PIN, PIN_MODE_OUTPUT);
    rt_pin_write(LED9_PIN, PIN_HIGH);

    while (1)
    {
      rt_pin_write(LED9_PIN, PIN_LOW);
      rt_thread_mdelay(100);

      rt_pin_write(LED9_PIN, PIN_HIGH);
      rt_thread_mdelay(200);
    }
}

int led_fast_start(void)
{
    led_fast_flash = rt_thread_create("led_fast",
                                      led_fast_flash_thread, 
                                      RT_NULL,
                                      LED_FAST_STACK_SIZE,
                                      LED_FAST_PRIORITY, 
                                      LED_FAST_TIMESLICE);

    if (led_fast_flash != RT_NULL)
        rt_thread_startup(led_fast_flash);
    
    return 0;
}

MSH_CMD_EXPORT(led_fast_start, led fast flash start);


/*-------------------------------   线程3：慢闪   -------------------------------*/
static rt_thread_t led_slow_flash = RT_NULL;

static void led_slow_flash_thread(void *parameter)
{
    rt_pin_mode(LED10_PIN, PIN_MODE_OUTPUT);
    rt_pin_write(LED10_PIN, PIN_HIGH);

    while (1)
    {
      rt_pin_write(LED10_PIN, PIN_LOW);
      rt_thread_mdelay(200);

      rt_pin_write(LED10_PIN, PIN_HIGH);
      rt_thread_mdelay(800);
    }
}

int led_slow_start(void)
{
    led_slow_flash = rt_thread_create("led_slow",
                                      led_slow_flash_thread, 
                                      RT_NULL,
                                      LED_SLOW_STACK_SIZE,
                                      LED_SLOW_PRIORITY, 
                                      LED_SLOW_TIMESLICE);

    if (led_slow_flash != RT_NULL)
        rt_thread_startup(led_slow_flash);
    return 0;
}

MSH_CMD_EXPORT(led_slow_start, led slow flash start);
```

编译完成后，连接好串口，开发板上电，可以看到串口终端输出版本信息，按下 `TAB` 键，显示当前可以输入的指令：

<figure>
  <img src="./images/1rtosstart.gif" width=300 border=1>
</figure>

首先启动LED快速闪烁的线程：

<figure>
  <img src="./images/1ledfast.gif" width=200 border=1>
</figure>

<figure>
  <img src="./images/1ledfast_onboard.gif" width=120 >
</figure>

然后启动LED慢闪的线程：

<figure>
  <img src="./images/1ledslow.gif" width=200 border=1>
</figure>

<figure>
  <img src="./images/1ledslow_onboard.gif" width=120 >
</figure>

最后启动流水灯

<figure>
  <img src="./images/1ledflow.gif" width=200 border=1>
</figure>

<figure>
  <img src="./images/1ledflow_onboard.gif" width=120 >
</figure>

最终效果是这三个部分看起来各自独立的运行，如果想在裸机上实现这个效果，要去设计一个很精妙的执行顺序，还要去考虑实际业务上的逻辑，整个系统设计起来会无比复杂，最主要是调试起来牵一发而动全身，最后可能搞出了来也就是个一次性系统。

## 线程创建的大概步骤

拿出线程3看看这些代码大概讲了什么事情，并研究为了捏出一个完整的线程，我们需要在代码上做出哪些准备。

首先 RTT 的msh是个很有意思的东西，和Linux里的终端很像，可以在整个MCU系统运行起来的时候使用命令和内核交流，在代码里 `MSH_CMD_EXPORT();` 的作用就是向msh导出自己的命令。执行命令就是去运行一个函数，这个函数也可是带参数的。

线程的所有相关信息都保存在 `led_slow_flash` 里，这是个指针，在线程初始化的时候会为这个指针分配内存，并设置数据，这就是 `rt_thread_create` 里面做的事情，可以认为传入的参数都是在为这个指针指向的结构体赋值。

```c
static rt_thread_t led_slow_flash = RT_NULL;

static void led_slow_flash_thread(void *parameter)
{
    rt_pin_mode(LED10_PIN, PIN_MODE_OUTPUT);
    rt_pin_write(LED10_PIN, PIN_HIGH);

    while (1)
    {
      rt_pin_write(LED10_PIN, PIN_LOW);
      rt_thread_mdelay(200);

      rt_pin_write(LED10_PIN, PIN_HIGH);
      rt_thread_mdelay(800);
    }
}

int led_slow_start(void)
{
    led_slow_flash = rt_thread_create("led_slow",
                                      led_slow_flash_thread, 
                                      RT_NULL,
                                      LED_SLOW_STACK_SIZE,
                                      LED_SLOW_PRIORITY, 
                                      LED_SLOW_TIMESLICE);

    if (led_slow_flash != RT_NULL)
        rt_thread_startup(led_slow_flash);
    return 0;
}

MSH_CMD_EXPORT(led_slow_start, led slow flash start);
```

这段程序写在 'led.c' 里，使用操作系统以后可以认为这是个功能，这个功能非常灵活，是可**拆卸**的，注意这个用词。

只需要这段代码，我们不需要再去修改任何其他文件，只要把这个源文件添加到keil工程里，编译以后就可以去msh运行了，这是真正意义上的模块化，向工程增加删除源文件的感觉和拆卸的感觉很像。


## RT-Thread 线程与线程控制块

RT-Thread 中存在两类线程，分别是**系统线程**和**用户线程**。系统线程是由 RT-Thread 内核创建的线程，用户线程是由应用程序创建的线程.

<figure>
    <img src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/thread/figures/04Object_container.png" width=450 />
</figure>

每个线程都有一个**线程控制块**，这个东西里面存放了所有和线程有关的信息，有点像句柄。它定义在 `rtdef.h` 文件内：

```c
/* 线程控制块 */
struct rt_thread
{
    /* rt 对象 */
    char        name[RT_NAME_MAX];     /* 线程名称 */
    rt_uint8_t  type;                   /* 对象类型 */
    rt_uint8_t  flags;                  /* 标志位 */

    rt_list_t   list;                   /* 对象列表 */
    rt_list_t   tlist;                  /* 线程列表 */

    /* 栈指针与入口指针 */
    void       *sp;                      /* 栈指针 */
    void       *entry;                   /* 入口函数指针 */
    void       *parameter;              /* 参数 */
    void       *stack_addr;             /* 栈地址指针 */
    rt_uint32_t stack_size;            /* 栈大小 */

    /* 错误代码 */
    rt_err_t    error;                  /* 线程错误代码 */
    rt_uint8_t  stat;                   /* 线程状态 */

    /* 优先级 */
    rt_uint8_t  current_priority;    /* 当前优先级 */
    rt_uint8_t  init_priority;        /* 初始优先级 */
    rt_uint32_t number_mask;

    /* 还有其他数据 */
};

typedef struct rt_thread *rt_thread_t;
```

`rt_thread_t` 为用于描述线程的结构体的指针的类型别名，这也很合理。线程控制块里有优先级、线程名称、线程状态等，也包含线程与线程之间连接用的链表结构，线程等待事件集合等。

## 线程栈

RT-Thread 线程具有独立的栈。这也是为了解决线程切换时中间数据的问题。

线程栈在线程切换时，将当前线程的上下文存在栈中，当线程要恢复运行时，再从栈中读取上下文信息，进行恢复；也用来存放函数中的局部变量：函数中的局部变量从线程栈空间中申请；函数中局部变量初始时从寄存器中分配（ARM 架构），当这个函数再调用另一个函数时，这些局部变量将放入栈中。


对于线程第一次运行，可以以手工的方式构造这个上下文来设置一些初始的环境：入口函数（PC 寄存器）、入口参数（R0 寄存器）、返回位置（LR 寄存器）、当前机器运行状态（CPSR 寄存器）。

线程栈的增长方向是芯片构架密切相关的，RT-Thread 3.1.0 以前的版本，均只支持栈由高地址向低地址增长的方式，对于 ARM Cortex-M 架构，线程栈可构造如下图所示。

<figure>
    <img src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/thread/figures/04thread_stack.png" width=250 />
</figure>


```note
线程栈大小可以这样设定小方法：

对于资源相对较大的 MCU，在初始时设置较大的栈，例如指定大小为 1K 或 2K 字节，然后在 FinSH 中用 list_thread 命令查看线程运行的过程中线程所使用的栈的大小，通过此命令，能够看到从线程启动运行时，到当前时刻点，线程使用的最大栈深度，而后加上适当的余量形成最终的线程栈大小，最后对栈空间大小加以修改。
```

## 线程优先级与时间片

优先级是线程被调度的优先程度。

RT-Thread 最大支持 256 个线程优先级 (0~255)，数值越小的优先级越高，0 为最高优先级。在一些资源比较紧张的系统中，可以根据实际情况选择只支持 8 个或 32 个优先级的系统配置；对于 ARM Cortex-M 系列，普遍采用 32 个优先级。最低优先级默认分配给空闲线程使用，用户一般不使用。


每个线程都有时间片这个参数，但**时间片仅对优先级相同的就绪态线程有效**。系统对优先级相同的就绪态线程采用时间片轮转的调度方式进行调度时，时间片起到约束线程单次运行时长的作用，其单位是一个系统节拍（OS Tick），详见《时钟管理》章节。假设有 2 个优先级相同的就绪态线程 A 与 B，A 线程的时间片设置为 10，B 线程的时间片设置为 5，那么当系统中不存在比 A 优先级高的就绪态线程时，系统会在 A、B 线程间来回切换执行，并且每次对 A 线程执行 10 个节拍的时长，对 B 线程执行 5 个节拍的时长。

<figure>
    <img src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/thread/figures/04time_slience.png" width=500 />
</figure>

## 线程任务函数

线程控制块中的 entry 是线程的入口函数地址。这一部分就是真正完成实际业务功能的地方，这里可以和裸机一样一个死循环一直运行，也可以只运行一次，也可以执行指定次数。

```c
void thread_entry(void* paramenter)
{
    while (1)
    {
    /* 等待事件的发生 */

    /* 对事件进行服务、进行处理 */
    }
}
```

```c
void thread_entry(void* parameter)
{
    /* 处理事务 #1 */
    …
    /* 处理事务 #2 */
    …
    /* 处理事务 #3 */
}
```

```c
void thread_entry(void* parameter)
{
    rt_uint8_t count;
    for(count = 0 ; count < 10 ;count++)
    {       

    }
}
```

一个线程就是一个执行场景，每个线程配备了一个变量用于保存错误码，错误码是与执行环境密切相关的，有以下几种：
```c
#define RT_EOK           0 /* 无错误     */
#define RT_ERROR         1 /* 普通错误     */
#define RT_ETIMEOUT      2 /* 超时错误     */
#define RT_EFULL         3 /* 资源已满     */
#define RT_EEMPTY        4 /* 无资源     */
#define RT_ENOMEM        5 /* 无内存     */
#define RT_ENOSYS        6 /* 系统不支持     */
#define RT_EBUSY         7 /* 系统忙     */
#define RT_EIO           8 /* IO 错误       */
#define RT_EINTR         9 /* 中断系统调用   */
#define RT_EINVAL       10 /* 非法参数      */
```


## 线程状态

RT-Thread 中线程的五种状态，如下表所示：

|状态|描述|宏定义|
|-|-|-|
|初始状态|线程刚创建未运行。初始状态下，线程不参与调度。| RT_THREAD_INIT
|就绪状态|在就绪状态下，线程按照优先级排队，等待被执行；一旦当前线程运行完毕让出处理器，操作系统会马上寻找最高优先级的就绪态线程运行。 | RT_THREAD_READY
|运行状态|线程当前正在运行。在单核系统中，只有 rt_thread_self() 函数返回的线程处于运行状态；在多核系统中，可能就不止这一个线程处于运行状态。| RT_THREAD_RUNNING
|挂起状态|也称阻塞态。资源不可用或主动延时而挂起。在挂起状态下，线程不参与调度。 |  RT_THREAD_SUSPEND
|关闭状态|当线程运行结束时将处于关闭状态。关闭状态的线程不参与线程的调度。| RT_THREAD_CLOSE


RT-Thread 提供一系列的操作系统调用接口，使得线程的状态在这五个状态之间来回切换。几种状态间的转换关系如下图所示：

<figure>
    <img src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/thread/figures/04thread_sta.png" width=650 />
</figure>

就绪和运行其实意思差不多，等同的。初始化函数的 init 和 create 用词上细微的差别，对应了静态建立和动态创建。

统线程是指由系统创建的线程，用户线程是由用户程序调用线程管理接口创建的线程，在 RT-Thread 内核中的系统线程有空闲线程和主线程。

空闲线程（idle）是系统创建的最低优先级的线程，线程状态永远为就绪态。当系统中无其他就绪线程存在时，调度器将调度到空闲线程，它通常是一个死循环，且永远不能被挂起。另外，空闲线程在 RT-Thread 也有着它的特殊用途：

若某线程运行完毕，系统将自动删除线程：自动执行 rt_thread_exit() 函数，先将该线程从系统就绪队列中删除，再将该线程的状态更改为关闭状态，不再参与系统调度，然后挂入 rt_thread_defunct 僵尸队列（资源未回收、处于关闭状态的线程队列）中，最后空闲线程会回收被删除线程的资源。

空闲线程也提供了接口来运行用户设置的钩子函数，在空闲线程运行时会调用该钩子函数，适合钩入功耗管理、看门狗喂狗等工作。空闲线程必须有得到执行的机会，即其他线程不允许一直while(1)死卡，必须调用具有阻塞性质的函数；否则例如线程删除、回收等操作将无法得到正确执行。

在系统启动时，系统会创建 main 线程，它的入口函数为 main_thread_entry()，用户的应用入口函数 main() 就是从这里真正开始的，系统调度器启动后，main 线程就开始运行，过程如下图，用户可以在 main() 函数里添加自己的应用程序初始化代码。

