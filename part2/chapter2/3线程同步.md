---
sort: 3
---
# 线程同步

多个线程在 RTOS 中并发向前推进，多个线程并发执行过程中，并不一定完全独立，会相互依赖。如何在 RTOS 中实现这些依赖关系，就是同步问题。

同步就是一个线程在需要同步的地方停下来等待依赖的进程，线程同步就是通过对线程等待和唤醒控制来让多个线程步调一致。

例如一项工作中的两个线程：一个线程从传感器中接收数据并且将数据写到共享内存中，同时另一个线程周期性的从共享内存中读取数据并发送去显示：

<figure>
    <img src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/ipc1/figures/06inter_ths_commu1.png" width=500 >
</figure>

这种情况下会遇到这么几个问题：
- 1.读出前写入未完成
- 2.

也就是说这两个线程访问这块内存的动作不可以同时进行。

同步是指按预定的先后次序进行运行，线程同步是指多个线程通过特定的机制（如互斥量，事件对象，临界区）来控制线程之间的执行顺序，也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间将是无序的。


多个线程操作 / 访问同一块区域（代码），这块代码就称为临界区，上述例子中的共享内存块就是临界区。线程互斥是指对于临界区资源访问的排它性。当多个线程都要使用临界区资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。

线程的同步方式有很多种，其核心思想都是：在访问临界区的时候只允许一个 (或一类) 线程运行。进入 / 退出临界区的方式有很多种：

- 1）调用 rt_hw_interrupt_disable() 进入临界区，调用 rt_hw_interrupt_enable() 退出临界区；详见《中断管理》的全局中断开关内容。

- 2）调用 rt_enter_critical() 进入临界区，调用 rt_exit_critical() 退出临界区。


## 信号量(semaphore)

### 使用接口

<figure>
    <img src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/ipc1/figures/06sem_ops.png" width=370 >
</figure>

```c
typedef struct rt_semaphore* rt_sem_t;

 rt_sem_t rt_sem_create(const char *name,
                        rt_uint32_t value,
                        rt_uint8_t flag);

rt_err_t rt_sem_delete(rt_sem_t sem);

rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time);

rt_err_t rt_sem_release(rt_sem_t sem);
```

### 信号量使用示例

使用大疆的 Robomaster 开发板 a 板，主控芯片是 STM32F427 ，使用一个LED。设计2个线程
- 1.每隔1s释放信号量，控制台输出信息
- 2.等待信号量，点亮LED输出控制信息

```c
#include <rtthread.h>
#include <rtdevice.h>
#include <board.h>

#define LED   GET_PIN(G, 8)

#define SEM_RELEASE_PRIORITY         11
#define SEM_RELEASE_STACK_SIZE       256
#define SEM_RELEASE_TIMESLICE        5

#define SEM_LED_PRIORITY         10
#define SEM_LED_STACK_SIZE       256
#define SEM_LED_TIMESLICE        5

/*------------------------- 信号量 -----------------------*/
static rt_sem_t sem = RT_NULL;

/*------------------------ 线程1 --------------------------*/
static rt_thread_t release = RT_NULL;

static void release_thread(void *parameter)
{
  rt_pin_mode(LED, PIN_MODE_OUTPUT);
  
  while(1)
  {
    rt_sem_release(sem);
    rt_kprintf("sem realeased.\n");
    
    rt_thread_mdelay(1000);
  }
}

/*------------------------ 线程2 --------------------------*/
static rt_thread_t led;

static void led_thread(void *parameter)
{
  static rt_err_t result;
  static rt_uint32_t number = 0;
  while(1)
  {
    /* 永久方式等待信号量，获取到信号量，则执行 number 自加的操作 */
    result = rt_sem_take(sem, RT_WAITING_FOREVER);
    if (result != RT_EOK)
    {
      rt_kprintf("t2 take a dynamic semaphore, failed.\n");
      rt_sem_delete(sem);
      return;
    }
    else
    {
      number++;
      rt_kprintf("t2 take a dynamic semaphore. number = %d\n" ,number);
    
      rt_pin_write(LED, PIN_LOW);
      rt_thread_mdelay(100);
      rt_pin_write(LED, PIN_HIGH);
      rt_thread_mdelay(100);
    }
  }
}

/*------------------------ 信号量示例的初始化 --------------------------*/
int sem_sample(int argc, char *argv[])
{
    /* 创建一个动态信号量，初始值是 0 */
    sem = rt_sem_create("sem",(rt_uint32_t)(argv[1][0]-'0'), RT_IPC_FLAG_PRIO);
    if (sem == RT_NULL)
    {
        rt_kprintf("create dynamic semaphore failed.\n");
        return -1;
    }
    else
    {
        rt_kprintf("create done. dynamic semaphore value = %d.\n",sem->value);
    }
    
    release = rt_thread_create("sem_release",
                                release_thread,
                                RT_NULL,
                                SEM_RELEASE_TIMESLICE,
                                SEM_RELEASE_PRIORITY,
                                SEM_RELEASE_TIMESLICE);
    if(release!=RT_NULL)
      rt_thread_startup(release);

    
    led = rt_thread_create("led_thread",
                            led_thread, 
                            RT_NULL,
                            SEM_LED_STACK_SIZE,
                            SEM_LED_PRIORITY,
                            SEM_LED_TIMESLICE);
    if(led!=RT_NULL)
      rt_thread_startup(led);
    
    return 0;
}
/* 导出到 msh 命令列表中 */
MSH_CMD_EXPORT(sem_sample, semaphore sample);
```

这里把实力函数导出为一个带参数的msh命令，和主函数的参数是一样的。


## 互斥量(mutex)

### 使用接口

```c
typedef struct rt_mutex* rt_mutex_t;

rt_mutex_t rt_mutex_create (const char* name, rt_uint8_t flag);

rt_err_t rt_mutex_delete (rt_mutex_t mutex);

rt_err_t rt_mutex_take (rt_mutex_t mutex, rt_int32_t time);

rt_err_t rt_mutex_release(rt_mutex_t mutex);
```

### 设计思想

互斥量又叫相互排斥的信号量，是一种特殊的二值信号量。

互斥量的状态只有两种，开锁或闭锁。当线程持有它时，互斥量处于闭锁状态，由这个线程获得它的所有权。当这个线程释放它时，将对互斥量进行开锁，失去它的所有权。



## 事件集(event)

事件集也是线程间同步的机制之一，一个事件集可以包含多个事件，利用事件集可以完成一对多，多对多的线程间同步。

### 设计思想

事件集主要用于线程间的同步，与信号量不同，它的特点是可以实现一对多，多对多的同步。

一个线程与多个事件的关系可设置为：其中任意一个事件唤醒线程，或几个事件都到达后才唤醒线程进行后续的处理；同样，事件也可以是多个线程同步多个事件。这种多个事件的集合可以用一个 32 位无符号整型变量来表示，变量的每一位代表一个事件，线程通过 “逻辑与” 或“逻辑或”将一个或多个事件关联起来，形成事件组合。事件的 “逻辑或” 也称为是**独立型同步**，指的是线程与任何事件之一发生同步；事件 “逻辑与” 也称为是**关联型同步**，指的是线程与若干事件都发生同步。

RT-Thread 定义的事件集有以下特点：
- 1）事件只与线程相关，事件间相互独立：每个线程可拥有 32 个事件标志，采用一个 32 bit 无符号整型数进行记录，每一个 bit 代表一个事件；
- 2）事件仅用于同步，不提供数据传输功能；
- 3）事件无排队性，即多次向线程发送同一事件 (如果线程还未来得及读走)，其效果等同于只发送一次。

### 使用接口

```c
struct rt_event
{
    struct rt_ipc_object parent;    /* 继承自 ipc_object 类 */

    /* 事件集合，每一 bit 表示 1 个事件，bit 位的值可以标记某事件是否发生 */
    rt_uint32_t set;
};
/* rt_event_t 是指向事件结构体的指针类型  */
typedef struct rt_event* rt_event_t;
```
事件集控制块中含有与事件集相关的重要参数，在事件集功能的实现中起重要的作用。事件集相关接口如下图所示，对一个事件集的操作包含：创建 / 初始化事件集、发送事件、接收事件、删除 / 脱离事件集。

```c

rt_event_t rt_event_create(const char* name, rt_uint8_t flag);

rt_err_t rt_event_delete(rt_event_t event);

rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);

rt_err_t rt_event_recv(rt_event_t event,
                           rt_uint32_t set,
                           rt_uint8_t option,
                           rt_int32_t timeout,
                           rt_uint32_t* recved);


```




