---
sort: 3
---
# 线程同步

一项工作的完成往往可以通过多个线程协调的方式共同来完成。例如一项工作中的两个线程：一个线程从传感器中接收数据并且将数据写到共享内存中，同时另一个线程周期性的从共享内存中读取数据并发送去显示：

<figure>
    <img src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/ipc1/figures/06inter_ths_commu1.png" width=500 >
</figure>

这种情况下会遇到这么几个问题：
- 1.读出前写入未完成
- 2.

也就是说这两个线程访问这块内存的动作不可以同时进行。

同步是指按预定的先后次序进行运行，线程同步是指多个线程通过特定的机制（如互斥量，事件对象，临界区）来控制线程之间的执行顺序，也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间将是无序的。


多个线程操作 / 访问同一块区域（代码），这块代码就称为临界区，上述例子中的共享内存块就是临界区。线程互斥是指对于临界区资源访问的排它性。当多个线程都要使用临界区资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。

线程的同步方式有很多种，其核心思想都是：在访问临界区的时候只允许一个 (或一类) 线程运行。进入 / 退出临界区的方式有很多种：

- 1）调用 rt_hw_interrupt_disable() 进入临界区，调用 rt_hw_interrupt_enable() 退出临界区；详见《中断管理》的全局中断开关内容。

- 2）调用 rt_enter_critical() 进入临界区，调用 rt_exit_critical() 退出临界区。


## 信号量(semaphore)

### 信号量介绍

信号量是一个有非负值得变量。

### 信号量代码实现与接口

信号量控制块结构的详细定义如下：
```c
struct rt_semaphore
{
   struct rt_ipc_object parent;  /* 继承自 ipc_object 类 */
   rt_uint16_t value;            /* 信号量的值 */
};
/* rt_sem_t 是指向 semaphore 结构体的指针类型 */
typedef struct rt_semaphore* rt_sem_t;
```

rt_semaphore 对象从 rt_ipc_object 中派生，由 IPC 容器所管理，信号量的最大值是 65535。

信号量相关接口如下图所示，对一个信号量的操作包含：创建 / 初始化信号量、获取信号量、释放信号量、删除 / 脱离信号量。

<figure>
    <img src="https://www.rt-thread.org/document/site/rt-thread-version/rt-thread-standard/programming-manual/ipc1/figures/06sem_ops.png" width=370 >
</figure>


### 信号量示例1


## 互斥量(mutex)

### 互斥量介绍

互斥量又叫相互排斥的信号量，是一种特殊的二值信号量。

互斥量的状态只有两种，开锁或闭锁。当线程持有它时，互斥量处于闭锁状态，由这个线程获得它的所有权。当这个线程释放它时，将对互斥量进行开锁，失去它的所有权。

### 互斥量代码实现与接口

```c
struct rt_mutex
{
    struct rt_ipc_object parent;                /* 继承自 ipc_object 类 */

    rt_uint16_t          value;                   /* 互斥量的值 */
    rt_uint8_t           original_priority;     /* 持有线程的原始优先级 */
    rt_uint8_t           hold;                     /* 持有线程的持有次数   */
    struct rt_thread    *owner;                 /* 当前拥有互斥量的线程 */
};
/* rt_mutext_t 为指向互斥量结构体的指针类型  */
typedef struct rt_mutex* rt_mutex_t;
```

### 互斥量示例1


## 事件集(event)

事件集也是线程间同步的机制之一，一个事件集可以包含多个事件，利用事件集可以完成一对多，多对多的线程间同步。

### 事件集

事件集主要用于线程间的同步，与信号量不同，它的特点是可以实现一对多，多对多的同步。

一个线程与多个事件的关系可设置为：其中任意一个事件唤醒线程，或几个事件都到达后才唤醒线程进行后续的处理；同样，事件也可以是多个线程同步多个事件。这种多个事件的集合可以用一个 32 位无符号整型变量来表示，变量的每一位代表一个事件，线程通过 “逻辑与” 或“逻辑或”将一个或多个事件关联起来，形成事件组合。事件的 “逻辑或” 也称为是**独立型同步**，指的是线程与任何事件之一发生同步；事件 “逻辑与” 也称为是**关联型同步**，指的是线程与若干事件都发生同步。

RT-Thread 定义的事件集有以下特点：
- 1）事件只与线程相关，事件间相互独立：每个线程可拥有 32 个事件标志，采用一个 32 bit 无符号整型数进行记录，每一个 bit 代表一个事件；
- 2）事件仅用于同步，不提供数据传输功能；
- 3）事件无排队性，即多次向线程发送同一事件 (如果线程还未来得及读走)，其效果等同于只发送一次。

### 事件集代码实现

```c
struct rt_event
{
    struct rt_ipc_object parent;    /* 继承自 ipc_object 类 */

    /* 事件集合，每一 bit 表示 1 个事件，bit 位的值可以标记某事件是否发生 */
    rt_uint32_t set;
};
/* rt_event_t 是指向事件结构体的指针类型  */
typedef struct rt_event* rt_event_t;
```
事件集控制块中含有与事件集相关的重要参数，在事件集功能的实现中起重要的作用。事件集相关接口如下图所示，对一个事件集的操作包含：创建 / 初始化事件集、发送事件、接收事件、删除 / 脱离事件集。

```c

rt_event_t rt_event_create(const char* name, rt_uint8_t flag);

rt_err_t rt_event_delete(rt_event_t event);

rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);

rt_err_t rt_event_recv(rt_event_t event,
                           rt_uint32_t set,
                           rt_uint8_t option,
                           rt_int32_t timeout,
                           rt_uint32_t* recved);


```




