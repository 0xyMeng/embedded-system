
# 动态规划

动态规划的核心：**状态定义**，**状态转移方程**

## 动态规划的想法

怎么把这两个东西想出来。

启发思路，回溯中，子集型回溯，对于一个元素有选或不选两种思路。一些动态规划问题也可以用这两种思路来思考。

### 递归

打家劫舍。用递归的想法来考虑，问题的分解

思考过程：对于打家劫舍，可以先从边界开始思考，第一个或者最后一个的约束比较小，如果第 n 个不选，那么问题就变成了剩下 n - 1 个房子选或不选的问题。如果第 n 个选，那么问题就变成了剩下的 n - 2 个房子的问题。不断地重复下去。

回溯三问：
- 当前操作是什么？枚举第 i 个选/不选
- 子问题是什么？从前 i 个房子中获得最大金额和
- 下一个子问题？
  - 选：从前 i - 2 个中获得最大金额和
  - 不选：从前 i - 1 个中获得最大金额和

dfs(i) = max(dfs(i - 1), dfs(i - 2) + nums[i])

写程序之前想好入口参数和返回值是什么。回溯的时间负责度是指数级别，会超时，因此考虑优化。

### 记忆化搜索

**递归搜索 + 保存计算结果 = 记忆化搜索**。注意到 dfs 的计算，有时会传递进去相同的参数，但是还要展开计算。因此可以考虑记录一下计算值存储到 cache 数组。

这样的话递归的次数和节点数就是一样的，时间复杂度为 O(n)

优化后，时间复杂度和空间复杂度都是 O(n)

### 递推

算法中计算 max 发生在 dfs 函数调用结束后，也就是递归的归中才实际计算 max。

查看搜索树的话，使能看出从哪些点归回去的，那么就去掉递归中的递，只留下归。从下往上计算。

自上向下计算为记忆化搜索，自下向上计算就是递推。

记忆化搜索向递推的变换。

dfs(i) = max(dfs(i - 1), dfs(i - 2) + nums[i])

f[i] = max(f[i-1], f[i-2] + nums[i])

函数变数组，递归变循环。

这样的优化空间复杂度还是 O(n) 还可以接着优化。


f[i] 是现在要算的，f[i-1] 是上一个算出来的，f[i-2] 是上上个算出来的。也就是说，计算当前状态的，只需要知道上个状态的和上上个状态的，并不需要一整个数组。


## 0-1 背包问题

0-1 背包和完全背包是比较重要的 DP 模型，是`选或不选`思想的代表。















