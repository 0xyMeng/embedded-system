
# 回溯问题


- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等


## 组合

```c
int * single_out = NULL;
int single_out_len = 0;

int **result = NULL;
int result_len = 0;

void backtracking(int n, int k, int start)
{
    //保存结果
    if (single_out_len == k)
    {
        int *temp = malloc(k*sizeof(int));

        for (int i=0; i<k; i++)
        {
            temp[i] = single_out[i];
        }

        result[result_len] = temp;
        result_len++;

        return; //忘记加了
    }

    for (int i=start; i<=n; i++)
    {
        single_out[single_out_len] = i;
        single_out_len++;

        backtracking(n, k, i+1);

        single_out--;
    }
}

int** combine(int n, int k, int* returnSize, int** returnColumnSizes) {

    single_out = (int*)malloc(k*sizeof(int));
    result = malloc(5000*sizeof(int));

    result_len = 0; // 注释掉会出错，为什么？

    backtracking(n, k, 1);

    *returnSize = result_len;

    int **column = malloc(result_len*sizeof(int));

    for(int i=0; i<result_len; i++)
    {
        (*column)[i] = k;
    }

    return result;
}
```


## N 皇后

char ** single_out = NULL;
int single_Q_num = 0;

char ***result = NULL;
int result_len = 0;


void save_single_result(int n) 
{
    char **temp = (char**)malloc(sizeof(char) * (n + 1)*n);

    for(int i = 0; i < (n + 1)*n; i++) {
        **(temp + i) = ** (single_out + i);
    }

    result[result_len] = temp;
    result_len++;
}


int is_ok(int x, int y, int n) {

    char ** path =  single_out;

    int i, j;
    //检查同一行以及同一列是否有效
    for(i = 0; i < n; ++i) {
        if(path[y][i] == 'Q' || path[i][x] == 'Q')
            return 0;
    }
    //下面两个for循环检查斜角45度是否有效
    i = y - 1;
    j = x - 1;
    while(i >= 0 && j >= 0) {
        if(path[i][j] == 'Q')
            return 0;
        --i, --j;
    }

    i = y + 1;
    j = x + 1;
    while(i < n && j < n) {
        if(path[i][j] == 'Q')
            return 0;
        ++i, ++j;
    }

    //下面两个for循环检查135度是否有效
    i = y - 1;
    j = x + 1;
    while(i >= 0 && j < n) {
        if(path[i][j] == 'Q')
            return 0;
        --i, ++j;
    }

    i = y + 1;
    j = x -1;
    while(j >= 0 && i < n) {
        if(path[i][j] == 'Q')
            return 0;
        ++i, --j;
    }
    return 1;
}

void backtracking(int n, int j)
{
    if (single_Q_num == n)
    {
        save_single_result(n);

        return;
    }

    for (int i=0; i<n; i++)
    {
        if (is_ok(i, j, n) == 1)
        {
            single_out[j][i] = 'Q';
            single_Q_num++;

            backtracking(n, j + 1);

            single_out[j][i] = '.';
            single_Q_num--;

        }
    }
}


char*** solveNQueens(int n, int* returnSize, int** returnColumnSizes) {

    single_Q_num = 0;
    result_len = 0;

    single_out = (char **)malloc(sizeof(char)*(n+1)*n);

    result = (char ***)malloc(sizeof(char**)*100);

    memset(single_out, '.', (n+1)*n);

    for (int i=0;i<n;i++)
        single_out[i][n] = '\0';

    backtracking(n, 0);

    *returnSize = result_len;

    *returnColumnSizes = (int*)malloc(sizeof(int) * result_len);
    for(int i; i < result_len; i++) {
        (*returnColumnSizes)[i] = n;
    }

    return result;

}


