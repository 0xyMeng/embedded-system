
# 二叉树


## 递归思路

二叉树和递归。
- 二叉树问题的思考方式
- 为什么需要使用递归
- 为什么这种写法一定能算出正确答案
- 计算机如何执行递归
- 另一种递归思路

举例子，计算一个二叉树的最大深度(leetcode 104)，根节点到最远叶子节点的距离。一开始陷入二叉树的细节就不太好写代码了。先西靠整棵树和左右子树的关系。

```
整棵树的最大深度 = max(左子树的最大深度, 右子树的最大深度) + 1
```

要计算子树的最大深度，和计算整个树的深度这个问题是一样的。
- 原问题：计算整棵树的最大深度
- 子问题：计算左右子树的最大深度

做循环计算，在使用同一份代码，那么这种相似问题，按道理也应该使用同一份代码计算。但这里的子问题需要把计算结果返回给上一级问题。

子问题的规模比原问题小，不断向下(递)，但总有尽头，即边界条件，直接返回答案(归)。

为什么这么做是对的？理论依据，数学归纳法证明。

```c
#define MAX(a, b) (((a)>(b)) ? (a) : (b))

int maxDepth(struct TreeNode* root) {

    if (root == NULL)
        return 0;

    return MAX(maxDepth(root->left), maxDepth(root->right)) + 1;
}
```

时间复杂度为 O(n)，空间复杂度也是 O(n) 。return 怎么知道回到那个节点上去的，函数调用，栈帧。

另外一种思路，递归时除了把节点传下去，还可以把递归的层数传下去，同时维护一个全局变量，当层数大于最大值，就更新全局变量。
```c
#define MAX(a, b) (((a)>(b)) ? (a) : (b))

int result;

void f(struct TreeNode* root, int count)
{
    if (root == NULL)
        return;
    
    count++;
    result = MAX(count, result);
    f(root->left, count);
    f(root->right, count); 
}

int maxDepth(struct TreeNode* root) {

    result =0;
    f(root, 0);
    return result;
}
```

## 递归练习

### 判断相同二叉树(leetcode 100)

判断相同二叉树(leetcode 100)。根节点相同，然后左子树要相同，右子树也要相同。

```c
bool isSameTree(struct TreeNode* p, struct TreeNode* q) {

    if ( (p==NULL) || (q==NULL) )
        return p == q;
        
    return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
}
```

判断对称二叉树 leetcode 101 

```c
bool isSameTree(struct TreeNode* p, struct TreeNode* q) {
    if ( (p==NULL) || (q==NULL) )
        return p == q;
    return (p->val == q->val) && isSameTree(p->left, q->right) && isSameTree(p->right, q->left);
}

bool isSymmetric(struct TreeNode* root) {
    return isSameTree(root->left, root->right);
}
```

### 判断平衡二叉树

```c
#define MAX(a, b) (((a)>(b)) ? (a) : (b))
#define ABS(x)  (((x)>0) ? (x): (-(x)))

int max_depth(struct TreeNode* root)
{
    if (root == NULL)
        return 0;

    int l = max_depth(root->left);
    int r = max_depth(root->right);

    if ( l == -1 || r == -1)
        return -1;

    if (ABS(l-r) <= 1)
        return MAX(max_depth(root->left), max_depth(root->right)) + 1;
    else 
        return -1;
}

bool isBalanced(struct TreeNode* root) {

    if (max_depth(root) == -1)
        return false;
    return true;
}
```

### 叉树的右视图 leetcode 199

```c
#define MAX(a, b) (((a)>(b)) ? (a) : (b))
#define ABS(x)  (((x)>0) ? (x): (-(x)))

int max_depth;
int *result;

void find(struct TreeNode* root, int count)
{
    if (root == NULL)
        return;

    count++;
    
    if (count > max_depth)
    {
        result[max_depth] = root->val;
        max_depth = count;
    }

    find(root->right, count);
    find(root->left, count);
}


int* rightSideView(struct TreeNode* root, int* returnSize) {
    max_depth = 0;
    result = malloc(100*sizeof(int));

    find(root, 0);

    *returnSize = max_depth;
    return result;    
}
```

## 验证二叉搜索树


## 最近公共祖先

二叉树，前序遍历。

前序遍历的定义就是用递归定义的，二叉树本身也是用递归定义的。关于前中后，指的是中间节点的位置。
```c
void preorder(struct TreeNode* root, int* ret, int* returnSize)
{
    if (root==NULL)
        return;

    ret[*returnSize] = root->val;
    (*returnSize)++;

    preorder(root->left, ret, returnSize);
    preorder(root->right, ret, returnSize);
}


int* preorderTraversal(struct TreeNode* root, int* returnSize) {
    int* ret = (int*)malloc(sizeof(int) * 100);
    *returnSize = 0;
    preorder(root, ret, returnSize);
    return ret;
}
```

后序遍历。

```c
void back_order(struct TreeNode* root, int *size, int *out)
{
    if (root == NULL)
        return;

    back_order(root->left, size, out);
    back_order(root->right, size, out);

    out[(*size)] = root->val;
    (*size) ++;
}

int* postorderTraversal(struct TreeNode* root, int* returnSize) {

    int *ret_array = (int *)malloc(100*sizeof(int));
    *returnSize = 0;

    back_order(root, returnSize, ret_array);
    return ret_array;
}
```








